#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Create Skills - Skill Generator for OpenClaw
Based on Anthropic's Model Context Protocol (MCP) best practices

Author: 帅小呆1号
Date: 2026-02-23
"""

import argparse
import json
import os
import sys
from datetime import datetime
from pathlib import Path
from typing import Dict, List, Optional


class SkillGenerator:
    """Generator for OpenClaw skills following MCP principles."""
    
    def __init__(self, config: Dict):
        self.config = config
        self.skill_name = config['name']
        self.skill_type = config['type']
        self.output_dir = Path(config['output_dir'])
        
    def generate(self) -> str:
        """Generate the complete skill structure."""
        skill_dir = self.output_dir / self.skill_name
        scripts_dir = skill_dir / "scripts"
        
        # Create directories
        skill_dir.mkdir(parents=True, exist_ok=True)
        scripts_dir.mkdir(exist_ok=True)
        
        # Generate files
        files_created = []
        
        # 1. SKILL.md
        skill_md = self._generate_skill_md()
        (skill_dir / "SKILL.md").write_text(skill_md, encoding='utf-8')
        files_created.append("SKILL.md")
        
        # 2. config.json
        config_json = self._generate_config_json()
        (skill_dir / "config.json").write_text(
            json.dumps(config_json, indent=2), encoding='utf-8'
        )
        files_created.append("config.json")
        
        # 3. scripts/main.py
        main_py = self._generate_main_py()
        (scripts_dir / "main.py").write_text(main_py, encoding='utf-8')
        files_created.append("scripts/main.py")
        
        # 4. .gitignore
        gitignore = self._generate_gitignore()
        (skill_dir / ".gitignore").write_text(gitignore, encoding='utf-8')
        files_created.append(".gitignore")
        
        return str(skill_dir), files_created
    
    def _generate_skill_md(self) -> str:
        """Generate SKILL.md documentation."""
        skill_title = self.skill_name.replace('-', ' ').title()
        
        return f"""# {skill_title}

> {self.config['description']}

---

## Overview

This is a {self.skill_type} skill for OpenClaw.

**Type**: {self.skill_type}  
**Version**: {self.config['version']}  
**Author**: {self.config['author']}

---

## Installation

```bash
# Copy to OpenClaw skills directory
cp -r {self.skill_name} ~/.openclaw/skills/
```

---

## Usage

```bash
python3 ~/.openclaw/skills/{self.skill_name}/scripts/main.py --help
```

---

## Configuration

Edit `config.json` to customize:

```json
{{
  "name": "{self.skill_name}",
  "version": "{self.config['version']}",
  "type": "{self.skill_type}"
}}
```

---

## MCP Compliance

This skill follows the Model Context Protocol specification:
- JSON-RPC 2.0 message format
- Proper lifecycle management
- Structured input/output schemas

---

*Generated by create-skills v1.0.0*
"""
    
    def _generate_config_json(self) -> Dict:
        """Generate config.json."""
        return {
            "name": self.skill_name,
            "description": self.config['description'],
            "version": self.config['version'],
            "type": self.skill_type,
            "author": self.config['author'],
            "created": datetime.now().isoformat(),
            "mcp": {
                "protocol_version": "2025-06-18",
                "transport": self.config.get('transport', 'stdio'),
                "capabilities": self._get_capabilities()
            }
        }
    
    def _get_capabilities(self) -> Dict:
        """Get MCP capabilities based on skill type."""
        capabilities = {}
        
        if self.skill_type == 'tool':
            capabilities['tools'] = {"listChanged": True}
        elif self.skill_type == 'resource':
            capabilities['resources'] = {"listChanged": True}
        elif self.skill_type == 'prompt':
            capabilities['prompts'] = {"listChanged": True}
        elif self.skill_type == 'server':
            capabilities = {
                "tools": {"listChanged": True},
                "resources": {"listChanged": True},
                "prompts": {"listChanged": True}
            }
        
        return capabilities
    
    def _generate_main_py(self) -> str:
        """Generate main.py based on skill type."""
        generators = {
            'tool': self._generate_tool_main,
            'resource': self._generate_resource_main,
            'prompt': self._generate_prompt_main,
            'server': self._generate_server_main
        }
        
        generator = generators.get(self.skill_type, self._generate_tool_main)
        return generator()
    
    def _generate_tool_main(self) -> str:
        """Generate main.py for tool skills."""
        class_name = self.skill_name.replace('-', '_').title().replace('_', '')
        
        return f'''#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
{self.config['description']}

MCP Tool Implementation
"""

import argparse
import json
import sys
from typing import Any, Dict, List, Optional


class {class_name}Tool:
    """Main tool implementation."""
    
    def __init__(self):
        self.name = "{self.skill_name}"
        self.version = "{self.config['version']}"
    
    def get_tool_schema(self) -> Dict:
        """Return MCP tool schema."""
        return {{
            "name": "{self.skill_name}",
            "title": "{self.skill_name.replace('-', ' ').title()}",
            "description": "{self.config['description']}",
            "inputSchema": {{
                "type": "object",
                "properties": {{
                    "input": {{
                        "type": "string",
                        "description": "Input parameter"
                    }}
                }},
                "required": ["input"]
            }}
        }}
    
    def execute(self, arguments: Dict[str, Any]) -> Dict:
        """Execute the tool with given arguments."""
        # TODO: Implement your tool logic here
        input_value = arguments.get('input', '')
        
        result = {{
            "content": [
                {{
                    "type": "text",
                    "text": f"Processed: {{input_value}}"
                }}
            ]
        }}
        
        return result
    
    def run(self, args: argparse.Namespace) -> int:
        """Main entry point."""
        if args.schema:
            print(json.dumps(self.get_tool_schema(), indent=2))
            return 0
        
        if args.input:
            try:
                arguments = json.loads(args.input)
                result = self.execute(arguments)
                print(json.dumps(result, indent=2))
                return 0
            except json.JSONDecodeError as e:
                print(f"Error: Invalid JSON input - {{e}}", file=sys.stderr)
                return 1
            except Exception as e:
                print(f"Error: {{e}}", file=sys.stderr)
                return 1
        
        print("No action specified. Use --help for usage.")
        return 0


def main():
    parser = argparse.ArgumentParser(
        description="{self.config['description']}"
    )
    parser.add_argument(
        '--schema',
        action='store_true',
        help='Output MCP tool schema'
    )
    parser.add_argument(
        '--input',
        type=str,
        help='JSON input for tool execution'
    )
    
    args = parser.parse_args()
    
    tool = {class_name}Tool()
    return tool.run(args)


if __name__ == "__main__":
    sys.exit(main())
'''
    
    def _generate_resource_main(self) -> str:
        """Generate main.py for resource skills."""
        class_name = self.skill_name.replace('-', '_').title().replace('_', '')
        
        return f'''#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
{self.config['description']}

MCP Resource Implementation
"""

import argparse
import json
import sys
from typing import Any, Dict, List, Optional


class {class_name}Resource:
    """Main resource implementation."""
    
    def __init__(self):
        self.name = "{self.skill_name}"
        self.version = "{self.config['version']}"
    
    def get_resource_schema(self) -> Dict:
        """Return MCP resource schema."""
        return {{
            "uri": "{self.skill_name}://data",
            "name": "{self.skill_name.replace('-', ' ').title()} Data",
            "description": "{self.config['description']}",
            "mimeType": "application/json"
        }}
    
    def read(self, uri: str) -> Dict:
        """Read resource content."""
        # TODO: Implement resource reading logic
        return {{
            "contents": [
                {{
                    "uri": uri,
                    "mimeType": "application/json",
                    "text": json.dumps({{"data": "example"}})
                }}
            ]
        }}
    
    def run(self, args: argparse.Namespace) -> int:
        """Main entry point."""
        if args.schema:
            print(json.dumps(self.get_resource_schema(), indent=2))
            return 0
        
        if args.read:
            result = self.read(args.read)
            print(json.dumps(result, indent=2))
            return 0
        
        print("No action specified. Use --help for usage.")
        return 0


def main():
    parser = argparse.ArgumentParser(
        description="{self.config['description']}"
    )
    parser.add_argument(
        '--schema',
        action='store_true',
        help='Output MCP resource schema'
    )
    parser.add_argument(
        '--read',
        type=str,
        metavar='URI',
        help='Read resource at given URI'
    )
    
    args = parser.parse_args()
    
    resource = {class_name}Resource()
    return resource.run(args)


if __name__ == "__main__":
    sys.exit(main())
'''
    
    def _generate_prompt_main(self) -> str:
        """Generate main.py for prompt skills."""
        class_name = self.skill_name.replace('-', '_').title().replace('_', '')
        
        return f'''#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
{self.config['description']}

MCP Prompt Implementation
"""

import argparse
import json
import sys
from typing import Any, Dict, List, Optional


class {class_name}Prompt:
    """Main prompt implementation."""
    
    def __init__(self):
        self.name = "{self.skill_name}"
        self.version = "{self.config['version']}"
    
    def get_prompt_schema(self) -> Dict:
        """Return MCP prompt schema."""
        return {{
            "name": "{self.skill_name}",
            "description": "{self.config['description']}",
            "arguments": [
                {{
                    "name": "topic",
                    "description": "Topic for the prompt",
                    "required": True
                }}
            ]
        }}
    
    def get(self, arguments: Dict[str, Any]) -> Dict:
        """Get prompt content."""
        topic = arguments.get('topic', 'default')
        
        return {{
            "description": f"Prompt for {{topic}}",
            "messages": [
                {{
                    "role": "user",
                    "content": {{
                        "type": "text",
                        "text": f"Please help with: {{topic}}"
                    }}
                }}
            ]
        }}
    
    def run(self, args: argparse.Namespace) -> int:
        """Main entry point."""
        if args.schema:
            print(json.dumps(self.get_prompt_schema(), indent=2))
            return 0
        
        if args.args:
            try:
                arguments = json.loads(args.args)
                result = self.get(arguments)
                print(json.dumps(result, indent=2))
                return 0
            except json.JSONDecodeError as e:
                print(f"Error: Invalid JSON - {{e}}", file=sys.stderr)
                return 1
        
        print("No action specified. Use --help for usage.")
        return 0


def main():
    parser = argparse.ArgumentParser(
        description="{self.config['description']}"
    )
    parser.add_argument(
        '--schema',
        action='store_true',
        help='Output MCP prompt schema'
    )
    parser.add_argument(
        '--args',
        type=str,
        help='JSON arguments for prompt'
    )
    
    args = parser.parse_args()
    
    prompt = {class_name}Prompt()
    return prompt.run(args)


if __name__ == "__main__":
    sys.exit(main())
'''
    
    def _generate_server_main(self) -> str:
        """Generate main.py for server skills."""
        class_name = self.skill_name.replace('-', '_').title().replace('_', '')
        
        return f'''#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
{self.config['description']}

MCP Server Implementation
"""

import argparse
import json
import sys
from typing import Any, Dict, List, Optional


class {class_name}Server:
    """MCP Server implementation."""
    
    def __init__(self):
        self.name = "{self.skill_name}"
        self.version = "{self.config['version']}"
        self.tools = {{}}
        self.resources = {{}}
        self.prompts = {{}}
    
    def initialize(self) -> Dict:
        """Initialize MCP server."""
        return {{
            "protocolVersion": "2025-06-18",
            "capabilities": {{
                "tools": {{"listChanged": True}},
                "resources": {{"listChanged": True}},
                "prompts": {{"listChanged": True}}
            }},
            "serverInfo": {{
                "name": self.name,
                "version": self.version
            }}
        }}
    
    def list_tools(self) -> List[Dict]:
        """List available tools."""
        return [
            {{
                "name": "example_tool",
                "description": "An example tool",
                "inputSchema": {{
                    "type": "object",
                    "properties": {{}}
                }}
            }}
        ]
    
    def call_tool(self, name: str, arguments: Dict) -> Dict:
        """Execute a tool."""
        return {{
            "content": [
                {{
                    "type": "text",
                    "text": f"Tool {{name}} executed"
                }}
            ]
        }}
    
    def run_stdio(self):
        """Run server with stdio transport."""
        print("Starting MCP server (stdio transport)...", file=sys.stderr)
        
        for line in sys.stdin:
            try:
                message = json.loads(line)
                response = self._handle_message(message)
                if response:
                    print(json.dumps(response), flush=True)
            except json.JSONDecodeError:
                pass
    
    def _handle_message(self, message: Dict) -> Optional[Dict]:
        """Handle incoming MCP message."""
        method = message.get('method')
        
        if method == 'initialize':
            return {{
                "jsonrpc": "2.0",
                "id": message.get('id'),
                "result": self.initialize()
            }}
        
        # Add more method handlers here
        
        return None
    
    def run(self, args: argparse.Namespace) -> int:
        """Main entry point."""
        if args.transport == 'stdio':
            self.run_stdio()
        else:
            print(f"Transport {{args.transport}} not implemented")
            return 1
        return 0


def main():
    parser = argparse.ArgumentParser(
        description="{self.config['description']}"
    )
    parser.add_argument(
        '--transport',
        choices=['stdio', 'http'],
        default='stdio',
        help='Transport type (default: stdio)'
    )
    
    args = parser.parse_args()
    
    server = {class_name}Server()
    return server.run(args)


if __name__ == "__main__":
    sys.exit(main())
'''
    
    def _generate_gitignore(self) -> str:
        """Generate .gitignore file."""
        return """# Python
__pycache__/
*.py[cod]
*$py.class
*.so
.Python
*.egg-info/
dist/
build/

# IDE
.vscode/
.idea/
*.swp
*.swo

# Environment
.env
.env.local

# Output
output/
temp/
"""


def interactive_mode():
    """Run interactive skill creation."""
    print("=" * 60)
    print("  Create Skills - Interactive Mode")
    print("  Based on Anthropic MCP Best Practices")
    print("=" * 60)
    print()
    
    config = {}
    
    # Skill name
    while True:
        name = input("Skill name (kebab-case, e.g., 'my-awesome-skill'): ").strip()
        if name and '-' in name and name.replace('-', '').isalnum():
            config['name'] = name
            break
        print("  Please use kebab-case (letters, numbers, hyphens only)")
    
    # Description
    config['description'] = input("Description: ").strip() or "A useful skill"
    
    # Type
    print("\nSkill types:")
    print("  1. tool    - Executable functions (most common)")
    print("  2. resource - Data sources")
    print("  3. prompt  - Interaction templates")
    print("  4. server  - Full MCP server")
    
    type_choice = input("Select type (1-4) [default: 1]: ").strip() or "1"
    type_map = {'1': 'tool', '2': 'resource', '3': 'prompt', '4': 'server'}
    config['type'] = type_map.get(type_choice, 'tool')
    
    # Transport for server type
    if config['type'] == 'server':
        transport = input("Transport (stdio/http) [default: stdio]: ").strip() or "stdio"
        config['transport'] = transport
    
    # Author
    config['author'] = input("Author [default: OpenClaw User]: ").strip() or "OpenClaw User"
    
    # Version
    config['version'] = input("Version [default: 1.0.0]: ").strip() or "1.0.0"
    
    # Output directory
    config['output_dir'] = input("Output directory [default: ./output]: ").strip() or "./output"
    
    print("\n" + "=" * 60)
    print("Configuration:")
    for key, value in config.items():
        print(f"  {key}: {value}")
    print("=" * 60)
    
    confirm = input("\nGenerate skill? [Y/n]: ").strip().lower()
    if confirm in ('', 'y', 'yes'):
        return config
    else:
        print("Cancelled.")
        sys.exit(0)


def main():
    parser = argparse.ArgumentParser(
        description="Create Skills - Generate OpenClaw skills following MCP best practices"
    )
    
    parser.add_argument(
        '--interactive', '-i',
        action='store_true',
        help='Run in interactive mode'
    )
    parser.add_argument(
        '--name', '-n',
        type=str,
        help='Skill name (kebab-case)'
    )
    parser.add_argument(
        '--description', '-d',
        type=str,
        default='A useful skill',
        help='Skill description'
    )
    parser.add_argument(
        '--type', '-t',
        choices=['tool', 'resource', 'prompt', 'server'],
        default='tool',
        help='Skill type (default: tool)'
    )
    parser.add_argument(
        '--author', '-a',
        type=str,
        default='OpenClaw User',
        help='Author name'
    )
    parser.add_argument(
        '--version', '-v',
        type=str,
        default='1.0.0',
        help='Initial version'
    )
    parser.add_argument(
        '--transport',
        choices=['stdio', 'http'],
        default='stdio',
        help='Transport type for server skills'
    )
    parser.add_argument(
        '--output-dir', '-o',
        type=str,
        default='./output',
        help='Output directory'
    )
    parser.add_argument(
        '--quick', '-q',
        type=str,
        metavar='NAME',
        help='Quick create with default settings'
    )
    
    args = parser.parse_args()
    
    # Handle interactive mode
    if args.interactive:
        config = interactive_mode()
    # Handle quick create
    elif args.quick:
        config = {
            'name': args.quick,
            'description': f'A {args.type} skill',
            'type': args.type,
            'author': args.author,
            'version': args.version,
            'transport': args.transport,
            'output_dir': args.output_dir
        }
    # Handle normal mode
    elif args.name:
        config = {
            'name': args.name,
            'description': args.description,
            'type': args.type,
            'author': args.author,
            'version': args.version,
            'transport': args.transport,
            'output_dir': args.output_dir
        }
    else:
        parser.print_help()
        print("\nError: Either --interactive, --name, or --quick is required")
        sys.exit(1)
    
    # Generate skill
    try:
        generator = SkillGenerator(config)
        skill_dir, files = generator.generate()
        
        print(f"\n✅ Skill created successfully!")
        print(f"   Location: {skill_dir}")
        print(f"   Files created:")
        for f in files:
            print(f"     - {f}")
        print(f"\nNext steps:")
        print(f"  1. cd {skill_dir}")
        print(f"  2. Edit scripts/main.py to implement your logic")
        print(f"  3. Test with: python3 scripts/main.py --help")
        print(f"  4. Copy to OpenClaw: cp -r {config['name']} ~/.openclaw/skills/")
        
    except Exception as e:
        print(f"\n❌ Error creating skill: {e}", file=sys.stderr)
        sys.exit(1)


if __name__ == "__main__":
    main()
